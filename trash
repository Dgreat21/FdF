//	if (l.dir)
//	{
//		x = l.d0.x;
//		y = l.d0.y;
//		end = l.d1.x;
//	}
//	else
//	{
//		x = l.d0.y;
//		y = l.d0.x;
//		end = l.d1.y;
//	}

void	drawer_0(t_mlx win, t_line l)
{
	float	i;
	float	f;
	int		end;
	int		hue;

	hue = l.color;
	(l.dir) ? (i = l.d0.x) : (i = l.d0.y);
	(l.dir) ? (f = l.d0.y) : (f = l.d0.x);
	(l.dir) ? (end = (int)l.d1.x) : (end = (int)l.d1.y);
	--i;
	if (l.dir)
		while (++i <= end)
		{
			mlx_pixel_put(win.mp, win.wp, (int)i, (int)f, brightness(hue, 1 - fract(f)));
			mlx_pixel_put(win.mp, win.wp, (int)i, (int)f + 1, brightness(hue, fract(f)));
			f += l.k;
		}
	else
		while (++f <= end)
		{
			mlx_pixel_put(win.mp, win.wp, (int)i, (int)f, brightness(hue, 1 - fract(i)));
			mlx_pixel_put(win.mp, win.wp, (int)i + 1, (int)f, brightness(hue, fract(i)));
			i += l.k;
		}
}


//t_map	counter(int fd)
//{
//	int		i, j;
//	char	*line;
//	t_map	map;
//
//	i = 0;
//	while (get_next_line(fd, &line) == 1)
//	{
//		if (!i)
//			j = ft_word_counter(line, ' ');
//		else if (j != ft_word_counter(line, ' '))
//			error_notice("wrong coordinates number");
//		i++;
//	}
//	if (!i)
//		error_notice("no lines in the file");
//	map.i = i;
//	map.j = j;
//	map.x = 0;
//	map.y = 0;
//	(i % 2) ? map.y++ : (0);
//	(j % 2) ? map.x++ : (0);
//	allocator(map);
//	return (map);
//}


//t_map	counter(int fd)
//{
//	int		i, j;
//	char	*line;
//	t_map	map;
//
//	i = 0;
//	while (get_next_line(fd, &line) == 1)
//	{
//		if (!i)
//			j = ft_word_counter(line, ' ');
//		else if (j != ft_word_counter(line, ' '))
//			error_notice("wrong coordinates number");
//		i++;
//	}
//	if (!i)
//		error_notice("no lines in the file");
//
//	allocator(map);
//	return (map);
//}


//void	draw_vert(t_mlx win, t_line l)
//{
//	int y;
//
//	y = l.y0 - 1;
//	while (++y < l.y1)
//		mlx_pixel_put(win.mp, win.wp, l.x0, y, l.color);
//void	draw(t_line l)
//{
//	grad = dy / dx;//k
//	y = l.y0 + grad;
//	x = l.x0;
//	while (++x <= l.x1 - 1)
//	{
//		mlx_pixel_put(win.mp, win.wp, x, (int) y, brightness(l.color, 1 - fract(y)));
//		mlx_pixel_put(win.mp, win.wp, x, (int) y + 1, brightness(l.color, fract(y)));
//		y += grad;
//	}
//}
//

//void	draw_wu_line(t_mlx win, t_line l)//todo NORM
//{
//	float	dx;
//	float	dy;
//	float	x;
//	float	y;
//	float	grad;
//
//
//	if (l.dx >= l.dy)
//	{
////		grad = dy / dx;
////		y = l.y0 + grad;
////		x = l.x0;
////		while (++x <= l.x1 - 1)
////		{
////			mlx_pixel_put(win.mp, win.wp, x, (int)y, brightness(l.color, 1 - fract(y)));
////			mlx_pixel_put(win.mp, win.wp, x, (int)y + 1, brightness(l.color, fract(y)));
////			y += grad;
////		}
//		draw(win, l.y0, l.y1, l.x0, l.x1);
//	}
//	else
//	{
////		grad = dx / dy;
////		x = l.x0 + grad;
////		y = l.y0;
////		while (++y <= l.y1 - 1)
////		{
////			mlx_pixel_put(win.mp, win.wp, (int)x,  y, brightness(l.color, 1 - fract(x)));
////			mlx_pixel_put(win.mp, win.wp, (int)x + 1, y, brightness(l.color, fract(x)));
////			x += grad;
////		}
//		draw(win, l.x0, l.x1, l.y0, l.y1);
//	}
//}


//void	check_line_data(t_line *line)
//{
//	t_line	l;
//	int		f;
//
//
//	l = line;
//	if (l.x0 > l.x1)
//	{
//		ft_swap(&l.x0, &l.x1);
//		ft_swap(&l.y0, &l.y1);
//	}
//}


//void	draw_my_line(t_mlx win, t_line l)
//{
//	float	y;
//	float	k;
//	int		x;
//
//
//	check_line_data(&l);
//	if (l.x0 == l.x1)
//		draw_vert(win, l);
//	else
//}
//void	draw(t_mlx win, float f0, float f1, float i0, float i1)
//{
//	float	df;
//	float	di;
//	float	k;
//	float	f;
//	int		i;
//
//	df = f1 - f0;
//	di = i1 - i0;
//	k = df / di;
//	f = f0 + k;
//	i = (int)i0;
//	while (++i <= i1 - 1)
//	{
//		mlx_pixel_put(win.mp, win.wp, i, (int) f, brightness(color, 1 - fract(f)));
//		mlx_pixel_put(win.mp, win.wp, i, (int) f + 1, brightness(l.color, fract(f)));
//		f += grad;
//	}
//}

//void	drawer0(t_mlx win, t_line l)
//{
//	float	x;
//	float	y;
//	int		end;
//	int		hue;
//
//	hue = l.color;
//	x = (l.dir) ? (l.d0.x) : (l.d0.y);
//	y = (l.dir) ? (l.d0.y) : (l.d0.x);
//	end = (l.dir) ? (l.d1.x) : (l.d1.y);
//	--x;
//	if (l.dir)
//		while (++x <= end)
//		{
//			pixel(win, set_dot(x, y), brightness(hue, 1 - fract(y)));
//			pixel(win, set_dot(x, y + 1), brightness(hue, fract(y)));
//			y += l.k;
//		}
//	else
//		while (++x <= end)// часть которая работает по y
//		{
//			pixel(win, set_dot(y, x), brightness(hue, 1 - fract(x)));
//			pixel(win, set_dot(y + 1, x), brightness(hue, fract(x)));
//			y += l.k;
//		}
//}

typedef struct		s_map//TODO исправить это гавно, остатки ГК
//{
//	int				i;
//	int				j;
//	int				x;
//	int				y;
//}					t_map;

//
//t_map		mapper(int lines, int cols)
//{
//	t_map	data;
//
//	data.i = lines;
//	data.j = cols;
//	data.x = 0;
//	data.y = 0;
//	(data.i % 2) ? data.y++ : (0);
//	(data.j % 2) ? data.x++ : (0);
//	return (data);
//}

//void		xyz(int *coords, char *str, t_glist **map, t_map data)
//{
//	const int i = coords[Y];
//	const int j = coords[X];
//
//	if (!data.x)
//		map[i][j].x = (float)(j - data.j / 2);
//	else
//		map[i][j].x = (float)(j) - (float)(data.j / 2);
//	if (!data.y)
//		map[i][j].y = (float)(i - data.i / 2);
//	else
//		map[i][j].y = (float)(i) - (float)(data.i / 2);
//	map[i][j].z = ft_atoi(str);
//}

//t_glist		mapper_new(int lines, int cols)
//{
//	t_glist	data;
//
//	data.y = lines;//i
//	data.x = cols;//j
//	return (data);
//}

//t_glist		**allocator(t_map data)
//{
//	int		i;
//	int		cl;
//	t_glist	**map;
//
//	i = 0;
//	cl = 0;
//	if ((map = (t_glist **)malloc((data.i) * sizeof(t_glist *))) == NULL)
//		error_notice("Malloc error");
//	while (i < data.i)
//	{
//		if ((map[i] = (t_glist *)malloc((data.j) * sizeof(t_glist))) == NULL)
//		{
//			while (cl < i)
//			{
//				free(map[cl]);
//				cl++;
//			}
//			free(map);
//			error_notice("Lines malloc error");
//		}
//		i++;
//	}
//	return (map);
//}

//void		filler(t_map data, t_glist **map, char **stock)
//{
//	int		i;
//	int		j;
//	int		coords[2];
//	char	**line;
//
//	i = -1;
//	while (++i < data.i)
//	{
//		if (data.j != ft_word_counter(stock[i], ' '))
////		{
////			free_map(lines);
////			free_str(line, cols);
////			free_str(stock, lines);
//			error_notice("wrong coordinates number");
////		}
//		j = -1;
//		line = ft_strsplit(stock[i], ' ');
//		while (++j < data.j)
//		{
//			coords[0] = i;
//			coords[1] = j;
//			xyz(coords, line[j], map, data);
//		}
//	}
//}

//void	my_test()
//{
//	mlx_new_image();
//	mlx_put_image_to_window();
//
//}


//void		checker(char *buf)
//{
//	char	**stock;
//	t_glist	**map;
//	t_map	data;
//	int		lines;
//	int		cols;
//
//
//	lines = ft_word_counter(buf, '\n');
//	stock = ft_strsplit(buf, '\n');
//	cols = ft_word_counter(stock[0], ' ');
//	data = mapper(lines, cols);
//	map = allocator(data);
//	filler(data, map, stock);
//
//}


//int		brightness0(int color, float k)
//{
//	int	r;
//	int	g;
//	int	b;
//	int	res;
//
//	r = R & color;
//	g = G & color;
//	b = B & color;
//	r = r >> 16;
//	g = g >> 8;
//	r = round((float)r * k);
//	g = round((float)g * k);
//	b = round((float)b * k);
//	r = r << 16;
//	g = g << 8;
//	res = r | g | b;
//	return (res);
//}


// void show_x(t_mlx win, t_glist o)
// {
// 	t_line x1, x2;
// 	x1 = line(set_dot(o.x + MOVE, o.y), set_dot(o.x + L/2, o.y), WHITE);
// 	x2 = line(set_dot(o.x - MOVE, o.y), set_dot(o.x - L/2, o.y), YELLOW);
// 	drawer(win, x1);
// 	drawer(win, x2);
// }

// void show_y(t_mlx win, t_glist o)
// {
// 	t_line y1, y2;
// 	y1 = line(set_dot(o.x, o.y + MOVE), set_dot(o.x, o.y + L/2), GREEN);
// 	y2 = line(set_dot(o.x, o.y - MOVE), set_dot(o.x, o.y - L/2), BLUE);
// 	drawer(win, y1);
// 	drawer(win, y2);
// }

// void show_a(t_mlx win, t_glist o)
// {
// 	t_line a1, a2, a3;
// 	a1 = line(set_dot(o.x - MOVE, o.y - MOVE), set_dot(o.x - L, o.y - L/2), AQUA);
// 	a2 = line(set_dot(o.x - MOVE, o.y - MOVE), set_dot(o.x - L/2, o.y - L/2), FUCHSIA);
// 	a3 = line(set_dot(o.x - MOVE, o.y - MOVE), set_dot(o.x - L/2, o.y - L), OLIVE);
// 	drawer(win, a1);
// 	drawer(win, a2);
// 	drawer(win, a3);
// }

// void show_b(t_mlx win, t_glist o)
// {
// 	t_line b1, b2, b3;
// 	b1 = line(set_dot(o.x + MOVE, o.y - MOVE), set_dot(o.x + L, o.y - L/2), RED);
// 	b2 = line(set_dot(o.x + MOVE, o.y - MOVE), set_dot(o.x + L/2, o.y - L/2), MAROON);
// 	b3 = line(set_dot(o.x + MOVE, o.y - MOVE), set_dot(o.x + L/2, o.y - L), TEAL);
// 	drawer(win, b1);
// 	drawer(win, b2);
// 	drawer(win, b3);
// }

// void show_c(t_mlx win, t_glist o)
// {
// 	t_line c1, c2, c3;
// 	c1 = line(set_dot(o.x + MOVE, o.y + MOVE), set_dot(o.x + L, o.y + L/2), AQUA);
// 	c2 = line(set_dot(o.x + MOVE, o.y + MOVE), set_dot(o.x + L/2, o.y + L/2), FUCHSIA);
// 	c3 = line(set_dot(o.x + MOVE, o.y + MOVE), set_dot(o.x + L/2, o.y + L), OLIVE);
// 	drawer(win, c1);
// 	drawer(win, c2);
// 	drawer(win, c3);
// }

// void show_d(t_mlx win, t_glist o)
// {
// 	t_line d1, d2, d3;
// 	d1 = line(set_dot(o.x - MOVE, o.y + MOVE), set_dot(o.x - L, o.y + L/2), RED);
// 	d2 = line(set_dot(o.x - MOVE, o.y + MOVE), set_dot(o.x - L/2, o.y + L/2), MAROON);
// 	d3 = line(set_dot(o.x - MOVE, o.y + MOVE), set_dot(o.x - L/2, o.y + L), TEAL);
// 	drawer(win, d1);
// 	drawer(win, d2);
// 	drawer(win, d3);
// }

//void	ft_foreach_dot(t_mlx win, t_glist **tab, unsigned int *len,
//		t_glist (*f)(t_mlx, t_glist)
//{
//	int		i;
//	int		j;
//
//
//	i = -1;
//	while (++i < len[0])
//	{
//		j = -1;
//		while (++j < len[1])
//		{
//			if (win.opt.dt_mode)
//				(*f)(tab[i][j]);
//			else
//			{
//				++j;
//				(*f)(tab[i][j]);
//				drawer(win, line(tab[i][j], )
//			}
//		}
//	}
//}

//int		main(void)
//{
//	t_mlx	win;
////	int		color;
////	t_line	l;
//	t_glist	o;
//	t_glist	a;
//	t_glist	b;
//	t_glist	c;
//
//
////	o = set_dot(500 - MOVE, 500 - MOVE);
////	a = set_dot(500 + MOVE, 500 - MOVE);
////	b = set_dot(500 - MOVE, 500 + MOVE);
////	c = set_dot(500 + MOVE, 500 + MOVE);
//	win = window(1000, 1000);
//	//color = ft_atoi_base(av[1], 16);
////	show_x(win, o);
////	show_y(win, o);
////	show_a(win, o);
////	show_b(win, o);
////	show_c(win, o);
////	show_d(win, o);
////
////	show_x(win, a);
////	show_y(win, a);
////	show_a(win, a);
////	show_b(win, a);
////	show_c(win, a);
////	show_d(win, a);
////
////	show_x(win, b);
////	show_y(win, b);
////	show_a(win, b);
////	show_b(win, b);
////	show_c(win, b);
////	show_d(win, b);
////
////	show_x(win, c);
////	show_y(win, c);
////	show_a(win, c);
////	show_b(win, c);
////	show_c(win, c);
////	show_d(win, c);
//	//show_xyz(win);
//	mlx_loop(win.mp);
//	return (0);
//}
